package tetris;

import blocks.BlockList;
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class GameArea extends javax.swing.JPanel {
    private int rows, columns, cellSize;
    private BlockList blockList;
    private TetrisBlock block;
    private Color[][] background;

    public GameArea(JPanel placeholder) {
        this(placeholder, 20);
    }
    
    public GameArea(JPanel placeholder, int cellSize) {
        // initialize properties
        placeholder.setVisible(false);
        
        this.setBackground(placeholder.getBackground());
        this.setBorder(placeholder.getBorder());
        this.setBounds(placeholder.getBounds());
        
        this.cellSize = cellSize;
        this.rows = this.getHeight() / cellSize;
        this.columns = this.getWidth() / cellSize;
        this.blockList = new BlockList(this.columns, this.cellSize);
        
        this.background = new Color[this.rows][this.columns];
    }
    
    // controls
    public boolean moveBlockDown() {
           if (!this.isCollidingBottomEdge()) {
               this.block.moveBlockDown();
               repaint();       
               return true;
           }
           
           this.moveToBackground();
           return false;
    }
    
    public boolean moveBlockLeft() {
        if (!this.isCollidingLeftEdge() && !this.isCollidingBottomEdge()) {
            this.block.moveBlockLeft();
            repaint();
            return true;
        }
        
        return false;
    }
    
    public boolean moveBlockRight() {
        if (!this.isCollidingRightEdge() && !this.isCollidingBottomEdge()) {
            this.block.moveBlockRight();
            repaint();
            return true;
        }
        
        return  false;
    }
    
    public void dropBlock() {
        while (!this.isCollidingBottomEdge()) {
            this.moveBlockDown();
        }
        
        repaint();
    }
    
    public void rotateBlock() {
        this.block.rotate();
        repaint();
    }
    
    // collision detection
    private boolean isCollidingRightEdge() {
        return ((this.block.getShapeColumnLength() + this.block.getOffsetX()) * cellSize) >= this.getWidth();
    }
    
    private boolean isCollidingLeftEdge() {
        return (this.block.getOffsetX() * cellSize) <= 0;
    }
    
    private boolean isCollidingBottomEdge() {
        return ((this.block.getShapeRowLength() + this.block.getOffsetY()) * cellSize) >= this.getHeight();
    }
    
    public void setRandBlock() {
        this.block = this.blockList.getRandBlock();
        this.block.setOffsetX((int) (Math.random() * columns));
        this.block.setOffsetY(-this.block.getShapeRowLength());
    }
    
    private void drawBackground(Graphics g) {
        for (int i = 0; i < this.rows; i++) {
            for (int j = 0; j < this.columns; j++) {
                Color color = background[i][j];
                
                if (color != null) {
                    drawGridSquare(g, j, i, color);
                }
            }
        }
    }
    
    private void moveToBackground() {
        int rows = this.block.getShapeRowLength();
        int columns = this.block.getShapeColumnLength();
    
        for (int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++) {
                if (this.block.getShape()[i][j]) {
                    background[i + this.block.getOffsetY()][j + this.block.getOffsetX()] = this.block.getColor();
                }
            }
        }
    }
    
    private void drawBlock(Graphics g) {
        int x = block.getOffsetX();
        int y = block.getOffsetY();
        
        for (int i = 0; i < block.getShapeRowLength(); i++) {
            for (int j = 0; j < block.getShapeColumnLength(); j++) {
                if (block.getShape()[i][j]) {
                    drawGridSquare(g, x + j, y + i, this.block.getColor());
                }
            }
        }
    }
    
    private void drawGridSquare(Graphics g, int x, int y, Color color) {
        
        g.setColor(color);
        g.fillRoundRect(x * cellSize, y * cellSize, cellSize, cellSize, 5, 5);
        g.setColor(Color.BLACK);
        g.drawRoundRect(x * cellSize, y * cellSize, cellSize, cellSize, 5, 5);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        for (int i = 0; i < this.rows; i++) {
            for (int j = 0; j < this.columns; j++) {
                g.drawRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
        }
        
        drawBackground(g);
        drawBlock(g);
    }
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
