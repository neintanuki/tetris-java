package tetris;

import blocks.LBlock;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JPanel;
import javax.swing.KeyStroke;

public class GameArea extends javax.swing.JPanel {
    private int rows, columns, cellSize;
    private LBlock block;

    public GameArea(JPanel placeholder) {
        this(placeholder, 20);
    }
    
    public GameArea(JPanel placeholder, int cellSize) {
        // initialize properties
        placeholder.setVisible(false);
        
        this.setBackground(placeholder.getBackground());
        this.setBorder(placeholder.getBorder());
        this.setBounds(placeholder.getBounds());
        
        this.cellSize = cellSize;
        this.rows = this.getHeight() / cellSize;
        this.columns = this.getWidth() / cellSize;
        this.block = new LBlock(this.columns);
    }
    
    // controls
    public void moveBlockDown() {
        if (!this.isCollidingBottomEdge()) {
            this.block.moveBlockDown();
            repaint();        
        }
    }
    
    public void moveBlockLeft() {
        if (!this.isCollidingLeftEdge()) {
            this.block.moveBlockLeft();
            repaint();
        }
    }
    
    public void moveBlockRight() {
        if (!this.isCollidingRightEdge()) {
            this.block.moveBlockRight();
            repaint();        
        }
    }
    
    // collision detection
    public boolean isCollidingRightEdge() {
        return ((this.block.getShapeColumnLength() + this.block.getOffsetX()) * cellSize) >= this.getWidth();
    }
    
    public boolean isCollidingLeftEdge() {
        return (this.block.getOffsetX() * cellSize) <= 0;
    }
    
    public boolean isCollidingBottomEdge() {
        return ((this.block.getShapeRowLength() + this.block.getOffsetY()) * cellSize) >= this.getHeight();
    }
    
    private void drawBlock(Graphics g) {
        int x = block.getOffsetX();
        int y = block.getOffsetY();
        
        for (int i = 0; i < block.getShapeRowLength(); i++) {
            for (int j = 0; j < block.getShapeColumnLength(); j++) {
                if (block.getShape()[i][j]) {
                    g.setColor(Color.GREEN);
                    g.fillRoundRect((x + j) * cellSize, (y + i) * cellSize, cellSize, cellSize, 5, 5);
                    g.setColor(Color.BLACK);
                    g.drawRoundRect((x + j) * cellSize, (y + i) * cellSize, cellSize, cellSize, 5, 5);
                }
            }
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        for (int i = 0; i < this.rows; i++) {
            for (int j = 0; j < this.columns; j++) {
                g.drawRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
        }
        drawBlock(g);
    }
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
